import { parse as parseComments, ParsedComment, Tag } from "comment-parser";
import * as project from "../package.json";
import { remove } from "lodash";
import chalk from "chalk";

export function extract(path: string, source: string): string {
  return `
---!!! DO NOT MANUALLY EDIT THIS FILE !!!
---Generated by ${project.name} ${project.version}
---${project.homepage}
---
---Date: ${new Date().toUTCString()}
---Source: ${path}
---
---@meta

${members(source)}`;
}

function toLuaComment(text: string): string | null {
  if (text.length === 0) {
    return null;
  }
  return text
    .trim()
    .split("\n")
    .map((line) => `---${line}`)
    .join("\n");
}

function formatTag({ tag, name, type, description }: Tag): string {
  return (
    `@` + [tag, name, type, description].filter((s) => s.length > 0).join(" ")
  );
}

function members(source: string): string {
  const ast = parseComments(source);

  const members = ast.reduce((acc, c) => {
    const lua = extractDeclaration(c);
    const desc = toLuaComment(c.description);
    const tags =
      c.tags.length === 0
        ? null
        : c.tags.map(formatTag).map(toLuaComment).join("\n");
    acc.push(
      [desc, desc && tags && "---", tags, lua]
        .filter((s) => s != null)
        .join("\n")
    );
    return acc;
  }, [] as string[]);
  return members.join("\n\n");
}

const customTags = ["function", "metatable"];

/** Must be called _before_ tags are used, as it modifies the tags array */
function extractDeclaration(comment: ParsedComment): string | null {
  const rules = remove(comment.tags, (t) => customTags.includes(t.tag));

  if (rules.length === 0) {
    return null;
  }

  const [rule, ...unused] = rules;
  if (unused.length > 0) {
    console.warn(
      `Incompatible tags found in comment:\n` +
        chalk.rgb(255, 255, 0)(`${unused.map(formatTag).join("\n")}`) +
        `using: ${chalk.rgb(0, 255, 0)(formatTag(rule))}` +
        `\n---\n`
    );
  }

  switch (rule.tag) {
    case "function":
      const paramNames = comment.tags
        .filter((t) => t.tag === "param")
        .map((t) => t.name);

      return `function ${rule.name}(${paramNames.join(", ")}) end`;
    case "metatable":
      return `${rule.name} = {}`;
  }

  return null;
}
