import { parse, Tag, Comment } from "./parser";
import * as project from "../package.json";
import { logWarning } from "./log";
import { enumRule, functionRule, Rule, tableRule } from "./rules";
import { ensureFirstWord, formatTag, toLuaComment } from "./utility";
import { without } from "lodash";

export function extract(path: string, source: string): string {
  return `
---!!! DO NOT MANUALLY EDIT THIS FILE !!!
---Generated by ${project.name} ${project.version}
---${project.homepage}
---
---Date: ${new Date().toUTCString()}
---Source: ${path}
---
---@meta

${members(source)}`;
}

function mergeTables(comments: Comment[]): Comment[] {
  const byTable = new Map<string, Comment>();
  const result = [] as Comment[];

  comments.forEach((c) => {
    const tableTag =
      c.tags.find((t) => t.type === "table") ||
      c.tags.find((t) => t.type === "enum");

    if (tableTag != null) {
      const tableName = ensureFirstWord(tableTag);
      if (tableName != null) {
        if (byTable.has(tableName)) {
          const prev = byTable.get(tableName)!;

          // Merge descriptions with a blank line.
          if (c.description.length > 0) {
            prev.description.push("", ...c.description);
          }

          // Merge all tags, but skip the duplicate table tag.
          prev.tags.push(...without(c.tags, tableTag));

          // Exit early to remove comment from list.
          return;
        } else {
          byTable.set(tableName, c);
        }
      }
    }

    // If we didn't merge this comment into another.
    result.push(c);
  });

  return result;
}

function members(source: string): string {
  const comments = mergeTables(parse(source));
  const members = comments.reduce((acc, c) => {
    const lua = applyRules(c);
    const desc = toLuaComment(c.description);
    const tags =
      c.tags.length === 0
        ? null
        : c.tags
            .map(formatTag)
            .map((t) => toLuaComment(t.split("\n")))
            .join("\n");
    acc.push(
      [desc, desc && tags && "---", tags, lua]
        .filter((s) => s != null)
        .join("\n")
    );
    return acc;
  }, [] as string[]);
  return members.join("\n\n");
}

const ruleHandlers = {
  function: functionRule,
  table: tableRule,
  enum: enumRule,
} as Record<string, Rule | undefined>;

/**
 * Apply custom attribute rules, which may generate a declaration or remove tags from the comment.
 * @return Lua declaration or null.
 */
function applyRules(comment: Comment): string | null {
  const actualTags = [...comment.tags];
  const declarations = actualTags.reduce((acc, t) => {
    const handler = ruleHandlers[t.type];
    if (handler != null) {
      const declaration = handler(t, comment);
      if (declaration != null) {
        acc.push([t, declaration]);
      }
    }
    return acc;
  }, [] as [Tag, string][]);

  if (declarations.length == 0) {
    return null;
  }

  if (declarations.length > 1) {
    logWarning(
      `Incompatible attributes found:\n - ${declarations
        .map(([tag, _]) => formatTag(tag))
        .join("\n - ")}`
    );
  }

  return declarations[0][1];
}
